// Copyright (c) 2023, Karol Grzybowski
// SPDX-License-Identifier: Apache-2.0

using Anemone.Base.Profiling;
using Anemone.Framework;
using System;
using System.IO;

namespace Anemone.GenerateProject;
public static class GenerateTargetHeaders
{
    private const int Offset = 50;
    private static void WriteDefine(StreamWriter writer, string name, string value)
    {
        writer.WriteLine($@"#define {name,-Offset} ""{value}""");
    }

    private static void WriteDefine(StreamWriter writer, string name, int value)
    {
        writer.WriteLine($@"#define {name,-Offset} {value}");
    }

    private static void WriteDefine(StreamWriter writer, string name, bool value)
    {
        writer.WriteLine($@"#define {name,-Offset} {(value ? 1 : 0)}");
    }

    private static void WriteDefine(StreamWriter writer, string name, Guid value)
    {
        writer.WriteLine($@"#define {name,-Offset} ""{value:N}""");
    }

    public static void GenerateHeaders(TargetContext targetContext, ResolvedTarget target)
    {
        var projectContext = targetContext.Context;

        Directory.CreateDirectory(target.Rules.GeneratedFilesDirectory);


        using (var stream = new MemoryStream())
        {
            using (var writer = new StreamWriter(stream))
            {
                writer.WriteLine(@"// This file was generated by machine.");
                writer.WriteLine(@"// Do not edit this file - all changes will be lost.");
                writer.WriteLine(@"#ifndef ANEMONE_GENERATED_HEADERS_TARGET_PROPERTIES_HXX");
                writer.WriteLine(@"#define ANEMONE_GENERATED_HEADERS_TARGET_PROPERTIES_HXX");
                writer.WriteLine(@"#pragma once");


                writer.WriteLine();
                writer.WriteLine("// Product information");
                WriteDefine(writer, "ANEMONE_PRODUCT_NAME", projectContext.ProductName);
                WriteDefine(writer, "ANEMONE_PRODUCT_COMPANY", projectContext.ProductCompany);
                WriteDefine(writer, "ANEMONE_PRODUCT_COPYRIGHT", projectContext.ProductCopyright);
                WriteDefine(writer, "ANEMONE_PRODUCT_GUID", projectContext.ProductGuid);

                writer.WriteLine();
                writer.WriteLine("// Product version");
                WriteDefine(writer, "ANEMONE_VERSION", projectContext.ProductVersion.ToString());

                WriteDefine(writer, "ANEMONE_VERSION_MAJOR", projectContext.ProductVersion.Major);
                WriteDefine(writer, "ANEMONE_VERSION_MINOR", projectContext.ProductVersion.Minor);
                WriteDefine(writer, "ANEMONE_VERSION_BUILD", projectContext.ProductVersion.Build);
                WriteDefine(writer, "ANEMONE_VERSION_REVISION", projectContext.ProductVersion.Revision);

                writer.WriteLine();
                writer.WriteLine("// Target properties");
                WriteDefine(writer, "ANEMONE_TARGET_MONOLITHIC", target.Rules.LinkKind == TargetLinkKind.Monolithic);

                WriteDefine(writer, GetDefine(target.Rules.Kind), true);
                WriteDefine(writer, GetDefine(target.Rules.Configuration), true);
                WriteDefine(writer, GetDefine(target.Rules.Platform), true);
                WriteDefine(writer, GetDefine(target.Rules.Toolchain), true);
                WriteDefine(writer, GetDefine(target.Rules.Architecture), true);

                writer.WriteLine();
                writer.WriteLine(@"#endif // ANEMONE_GENERATED_HEADERS_TARGET_PROPERTIES_HXX");
            }

            var path = Path.Combine(target.Rules.GeneratedFilesDirectory, "AnemoneGeneratedTargetProperties.hxx");
            OverwriteIfChanged(path, stream);
        }
    }

    private static string GetDefine(TargetKind targetKind)
    {
        switch (targetKind)
        {
            case TargetKind.Game:
                return "ANEMONE_TARGET_GAME";
            case TargetKind.Editor:
                return "ANEMONE_TARGET_EDITOR";
            case TargetKind.Client:
                return "ANEMONE_TARGET_CLIENT";
            case TargetKind.Server:
                return "ANEMONE_TARGET_SERVER";
        }

        throw new ArgumentOutOfRangeException(nameof(targetKind));
    }

    private static string GetDefine(TargetConfiguration targetConfiguration)
    {
        switch (targetConfiguration)
        {
            case TargetConfiguration.Debug:
                return "ANEMONE_CONFIGURATION_DEBUG";
            case TargetConfiguration.GameDebug:
                return "ANEMONE_CONFIGURATION_GAMEDEBUG";
            case TargetConfiguration.EngineDebug:
                return "ANEMONE_CONFIGURATION_ENGINEDEBUG";
            case TargetConfiguration.Development:
                return "ANEMONE_CONFIGURATION_DEVELOPMENT";
            case TargetConfiguration.Testing:
                return "ANEMONE_CONFIGURATION_TESTING";
            case TargetConfiguration.Shipping:
                return "ANEMONE_CONFIGURATION_SHIPPING";
        }

        throw new ArgumentOutOfRangeException(nameof(targetConfiguration));
    }

    private static string GetDefine(TargetPlatform targetPlatform)
    {
        switch (targetPlatform)
        {
            case TargetPlatform.Windows:
                return "ANEMONE_PLATFORM_WINDOWS";
            case TargetPlatform.UniversalWindows:
                return "ANEMONE_PLATFORM_UNIVERSALWINDOWS";
            case TargetPlatform.XboxGaming:
                return "ANEMONE_PLATFORM_XBOXGAMING";
            case TargetPlatform.GamingDesktop:
                return "ANEMONE_PLATFORM_GAMINGDESKTOP";
            case TargetPlatform.Android:
                return "ANEMONE_PLATFORM_ANDROID";
            case TargetPlatform.Linux:
                return "ANEMONE_PLATFORM_LINUX";
        }

        throw new ArgumentOutOfRangeException(nameof(targetPlatform));
    }

    private static string GetDefine(TargetToolchain targetToolchain)
    {
        switch (targetToolchain)
        {
            case TargetToolchain.Default:
                break;
            case TargetToolchain.Clang:
                return "ANEMONE_TOOLCHAIN_CLANG";
            case TargetToolchain.ClangCL:
                return "ANEMONE_TOOLCHAIN_CLANGCL";
            case TargetToolchain.MSVC:
                return "ANEMONE_TOOLCHAIN_MSVC";
            case TargetToolchain.Intel:
                return "ANEMONE_TOOLCHAIN_INTEL";
            case TargetToolchain.GCC:
                return "ANEMONE_TOOLCHAIN_GCC";
        }

        throw new ArgumentOutOfRangeException(nameof(targetToolchain));
    }

    private static string GetDefine(TargetArchitecture targetArchitecture)
    {
        switch (targetArchitecture)
        {
            case TargetArchitecture.X64:
                return "ANEMONE_ARCHITECTURE_X64";
            case TargetArchitecture.AArch64:
                return "ANEMONE_ARCHITECTURE_AARCH64";
            case TargetArchitecture.RiscV64:
                return "ANEMONE_ARCHITECTURE_RISCV64";
        }

        throw new ArgumentOutOfRangeException(nameof(targetArchitecture));
    }

    public static void OverwriteIfChanged(string path, MemoryStream stream)
    {
        var content = stream.ToArray();
        var overwrite = !File.Exists(path) ||
            !File.ReadAllBytes(path).AsSpan().SequenceEqual(content);

        if (overwrite)
        {
            File.WriteAllBytes(path, content);
        }
    }

    public static void GenerateHeaders(TargetContext context)
    {
        using var scope = Profiler.Function();

        foreach (var resolvedTarget in context.ResolvedTargets)
        {
            GenerateHeaders(context, resolvedTarget);
        }
    }
}
